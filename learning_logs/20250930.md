# Spring Security 추가 정리

## 정의

- Spring 기반의 애플리케이션 보안(Authentication / Authorization)을 위한 표준 프레임워크. 서블릿 필터(Servlet Filter) 체인을 기반으로 동작함, 웹 요청에 대한 보안을 체계적으로 처리함. 단순한 로그인 기능 뿐만 아니라, CSRF 공격 방지, 세션 관리, 권한 기반 접근 제어 등 포괄적인 보안 기능을 제공.

## 특징

1. 포괄적 보안 기능 : 인증(Authentication) / 인가(Authorization) 뿐 아니라 일반적인 웹 보안 위협으로부터 애플리케이션을 보호.
2. 유연한 설정 : Java 기반의 설정을 통해 유연하게 보안 정책을 설정할 수 있음(우리가 해야한다는 뜻)
3. 서블릿 필터 기반 : _요청이 컨트롤러에 도달하기 전에_ 여러 보안 필터를 거치게 하여 선제적인 보안 검사를 수행.
4. SpringBoot와의 통합 : `spring-boot-starter-security` 의존성만 추가하면 기본적인 보안 기능이 자동 설정되어 빠르게 적용가능(default 로그인 페이지가 생겼고, password가 콘솔에 찍혔다).

## SecurityConfig

- Spring Security의 보안 구성(Config)을 담당하는 Java 설정 클래스로, 해당 클래스에는 `@Configuration, @EnableWebSecurity` 애너테이션을 추가하여 Spring Security의 웹 보안 설정을 활성화하고 커스터마이징을 할 수 있다.

- 과거에는 `@WebSecurityConfigurerAdapter`를 상속 받아서 configure() 메서드를 오버라이딩하는 방식으로 사용했었지만, SpringBoot 3.x 버전부터는 SecurityFilterChain 빈(bean)을 등록하는 방식이 권장된다. 현재의 방식은 컴포넌트 기반의 구성으로, 더욱 모듈화되고 유연한 보안 구성이 가능하다.

### SecurityConfig의 핵심 역할

1. HTTP 요청에 대한 접근 제어 : 특정 URL 패턴에 대해 인증된 사용자만 접근을 허용하거나, 특정 권한(Role)을 가진 사용자만 접근 가능하도록 설정 가능.
2. 인증 방식 설정 : 폼 로그인(Form Login), HTTP Basic 인증, OAuth2 로그인 등 다양한 인증 방식을 설정하고 커스터마이징 가능.
3. 로그아웃 처리 : 로그아웃 URL 및 로그아웃 성공 후 처리 로직을 정의
4. 비밀번호 암호화 : `PasswordEncoder`를 빈으로 등록하여 사용자의 비밀번호를 안전하게 암호화하고 검증하는 방식을 지정.
5. CSRF, CORS 설정 : CSRF 보호 기능을 활성화하거나 비활성화하고, CORS 정책을 구성한다.

### SecurityConfig 코드 예시

```java
@Configuraiton
@EnableWebSecurity
public class SecurityConfig{
  // 비밀 번호 등록을 위한 PasswordEncoder 빈을 등록
  @Bean
  public PasswordEncoder passwordaEncoder(){
    return new BCyptPasswordEncoder();
  }

  // Spring Security의 filterChain 작성
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
      // 1. 인가(Authorization) 구성
        .authorizeHttpRequests(authorize -> authorize
        .requestMatchers("/users/**").authenticated() // /users/** 경로는 인증된 user만 가능
        .requestMatchers("/manager/**").hasAnyRole("ADMIN", "MANAGER")  // /manager/** 경로는 role이 ADMIN이거나 MANAGER인 user만 가능
        .requestMatchers("/admin/**").hasRole("ADMIN")  // /admin/** 경로는 role이 ADMIN인 user만 가능
        .anyRequest().permitAll() // 나머지 경로에 대한 요청들은 접근을 허용함.
        )
        // 2. 폼 로그인(Form Login) 구성
        .formLogin(form -> form
          .LoginPage("/login")    // 커스텀 로그인 페이지의 URL 지정
          .loginProcessingUrl("/loginProc") // 로그인 처리 URL
          .defaultSucessUrl("/")  // 로그인 성공 시 이동할 default URL
          .permitAll()            // 로그인 페이지는 모든 사용자의 접근 가능
        )
        // 3. 로그아웃 설정
        .logout(logout -> logout
          .logoutUrl("/logout") // 로그아웃 처리  URL
          .logoutSuccessUrl("/")  // 로그아웃 성공 시 이동할 URL
          .invalidateHttpSession(true)  // 세션 무효화
          .deleteCookies("JSESSIONID")       // 쿠키 삭제
        )
        // 4. CSRF 보호 비활성화(API 서버의 경우)
        .csrf(csrf -> csrf.diable())
  }
}
```

- 이상의 코드의 상세 설명

  1. authorizeHttpRequests : HTTP 요청에 대한 인가 규칙을 구성.

  - requestMatchers() : 특정 URL 패턴을 지정
  - authenticated() : 인증된 사용자만 접근 허용
  - hasAnyRole(), hasRole() : 특정 역할을 가진 사용자만 접근을 허용. Spring Security에서 역할(Role)은 기본적으로 "ROLE\_" 접두사가 붙어서 처리된다(예시: hasRole("ADMIN")은 "ROLE_ADMIN" 역할을 확인한다는 의미)
  - permitAll() : 모든 사용자의 접근을 허용.
  - anyRequest() : 위에서 설정한 규칙 외의 모든 요청을 의미함. _그래서 인가 규칙의 경우 구체적인 경로를 먼저 구성하고, 포괄적인 경로는 나중에 구성해야 한다._

  2. formLogin : 폼 기반 로그인을 설정

  - loginPage() : 기본 제공되는 로그인 페이지 대신 사용할 커스텀 로그인 페이지의 경로를 지정.
  - loginProcessingUrl() : 로그인 폼 데이터를 처리할 URL을 지정. 이 URL에 대한 POST 요청을 Spring Security가 가로채서 인증을 처리함.
  - defaultSuccessUrl() : 로그인 성공 후 사용자를 리디렉션할 기본 페이지 설정.

  3. logout : 로그아웃 관련 설정.

  - logouturl() : 로그아웃을 처리할 URL을 지정.
  - logoutSuccessUrl() : 로그아웃 성공 후 리디렉션 될 페이지를 지정.
  - invaliddateHttpSession(true) : 로그아웃 시 HTTP 세션을 무효화.
  - deleteCookies("JSESSION") : 로그아웃 시 지정된 쿠키를 삭제.

  4. csrf(csrf -> csrf.disalbe()) : CSRF 보호 기능을 비활성화. 세션 기반 인증이 아닐 _JWT와 같은 토큰 기반 인증을 사용하는 API 서버의 경우 일반적으로 비활성화_

Java 관련 visual studio code Extension

Code Runner -> Java 프로젝트를 실행시키려면 필요
Debugger for Java
Extension Pack for Java

# 현재까지의 상황을 바탕으로 한 다음 단게 생각해보자

AppUser / AppUserReopository를 생성함으로써 DB에 AppUser 관련 테이블이 생성되고, Spring Security 의존성을 도입하여 default Login이 가능하다.

이제 보안 관련 로직을 현재 프로젝트에서 MVC 패턴에 맞게 설정할 필요가 있겠다.

1. 사용자 인증을 위한 Service 계층 구현 : Spring Security가 데이터베이스의 사용자 정보를 기반으로 인증을 수행할 수 있도록 UserDetailsService를 구현할 거다

- service 패키지 내에 UserDetailsServiceImpl 클래스를 생성하고 UserDetailsService를 구현하세요.

```java
@Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { // 강제로 오버라이딩 해야함
        Optional<AppUser> user = appUserRepository.findByUsername(username); // 결과값이 unique라서 Optional로 자료형을 지정함.
                                                                            // 직접 메서드를 생성함 -> AppRepository에서 자동 생성해줌.
        UserBuilder builder = null;
        if(user.isPresent()){
            AppUser currentUser = user.get(); // user 자체는 Optional 자료형이지 AppUser가 아니기 때문에 get으로 꺼내야한다.
            builder = withUsername(username);
            builder.password(currentUser.getPassword()).roles((currentUser.getRole()));
        } else {
            throw new UsernameNotFoundException("User Not Found.");
        }

        return builder.build();
    }
```

이상의 코드는 cardatabase_2의 UserDetailsServiceImpl과 코드라인이 일부 변경되었다. 그 과정 중에서 AppUserRepository의 내부에 findByUsername(String username) 추상 메서드를 정의했는데, 일반적인 방법으로 한 것이 아니라 오류를 발생시킨 다음에 intellij의 내부 기능을 사용하여 자동 생성했다.

또한 User 클래스를 가지고 온 것이 아니라 static 메서드를 import 하는 방식으로 코드라인을 줄였다

builder를 가지고 온 김에 chaining method를 도입하여 builder 객체를 생성했었다.

2. JWT 토큰 생성 및 검증 Service 구현 : 로그인 성공 시에 JWT 토큰을 발급하고, 이후의 모든 요청에서 토큰을 검증하는 JwtService를 만든다.

- 관련 의존성을 추가하고
- service 패키지에 JwtService 클래스를 생성

3. 로그인 Controller 및 관련 클래스 생성 : 로그인 요청 시에는 ID와 비밀번호를 담을거다. 그러니까 이게 꼭 AppUser Entity가 아니겠지. 그 때 우리는 뭐 새로 하나 만들었었다.

- domain 패키지 내에 AccountCredentials 라고 하는 Record 생성.
- web 패키지에 LoginController 생성

4. JWT 인증 필터 및 예외 처리 구현 : `/login`을 제외한 모든 API 요청을 가로채서 JWT 토큰의 유효성을 검사하는 Filter를 만들거다.

- 루트 프로젝트 패키지에 AuthencationFilter 클래스 생성

5. AuthEntryPoint(인증 실패 처리) : 로그인 실패 시에 현재대로라면 403 오류가 나아한다.(근데 저희는 cardatabase4에는 아직 SecurityConfig가 없어서 실행도 안된다) 이 부분을 401 처리 하기로 한다.

- 루트 프로젝트 패키지에 AuthEntryPoint 생성

6. 이상까지의 상황을 반영한 SecurityConfig 작성

- 루트 프로젝트 패키지에 SecurityConfig 생성

이상까지 작성했을 때 cardatabase_2와 좀 다른 부분듪이 있는데 보편적으로는 JwtService 시작지점에 `@Service / @Component`의 차이이다. 컴포넌트 애너테이션은 클래스 자체를 bean 등록하기 위한 것이라고 이미 설명했다. 서비스 애너테이션을 ctrl + 클릭 해보면 애초에 서비스 애너테이션이 컴포넌트 애너테이션을 상속받았음을 확인할 수 있다. 동일한 방식으로 `@RestController`도 ctrl + 클릭하면 `@Controller`를 상속 받았고, 또 얘를 클릭하면 내부에 `@Component`가 있음을 확인할 수 있다. 그러면 어차피 특정 클래스는 특정 역할을 한다고 애너테이션 명시를 하는 순간 `@Component`가 적용된다고 볼 수 있다.

7. 현재 AppUser를 객체 추가하려면 SQL문을 통하거나 혹은 CommandLineRunner를 통해서 해야할 것 같다. 이를 통해 생성된 AppUser객체를 가지고 로그인 성공 시 / 실패 시를 확인하면 spring-data-rest 없는 상태의 부분이 구현될 거 같다.

# 시험 예시 문제 1

온라인 서점에서 판매할 일반 도서(Book)와 전자책(EBook)을 관리하는 시스템을 구축하려고 한다. Book 클래스를 상속받는 EBook 클래스를 완성하고, 각 클래스의 객체를 생성하여 정보를 출럭하는 프로그램을 작성하세요.

요구사항 명세서 :

1. EBook 클래스는 title(제목)과 author(저자)를 필드로 가진다.

2. EBook 클래스는 Book 클래스를 상속받으며, fileSize(파일 크기) 필드를 추가로 가진다.

3. 각 클래스는 필드 정보를 출력하는 displayInfo() 메서드를 가진다. EBook 클래스의 displayInfo()는 Book의 메서드를 오버라이딩하여 파일 크기 정보까지 함께 출력해야 한다.

4. main 메서드에서 Book과 EBook 객체를 각각 생성하고, displayInfo() 메서드를 호출하여 아래 "실행 예"와 같이 출력되도록 코드를 완성하시오.

실행 예
제목: 자바의 정석, 저자: 남궁성
제목: 스프링 부트 3 백과사전, 저자: 김영한, 파일 크기: 20.5MB

# 문제 2

1. `makeSound()` 메서드를 가진 `Animal` 클래스를 만든다.
2. `Animal`을 상속하고 `makeSound()`를 오버라이딩하는 `Dog`, `Cat` 클래스를 만든다.
3. `Dog` 클래스에는 고유 메서드인 `fetch()`를 추가한다.
4. `Animal`타입의 배열 `animals`에 `Dog`, `Cat` 객체를 업캐스팅하여 저장한다.
5. 반복문을 통해 배열의 모든 동물이 각자의 소리를 내도록 `makeSound()`르 호출한다.
6. `instanceof` 연산자로 `Dog` 객체를 확인한 후, **다운캐스팅**하여 `fetch()` 메서드를 호출한다.
